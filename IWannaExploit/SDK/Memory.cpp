#include <iostream>
#include <Windows.h>
#include <tlhelp32.h>
#include <tchar.h>
#include <vector>
#include "Memory.h"

bool Memory::init() {

    char gameName[] = "I Wanna Maker.exe";
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);

    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

    if (Process32First(snapshot, &entry) == TRUE)
    {
        while (Process32Next(snapshot, &entry) == TRUE)
        {
            if (_stricmp(entry.szExeFile, gameName) == 0)
            {
                Memory::hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, entry.th32ProcessID);
                Memory::gameBaseAddress = GetModuleBaseAddress(gameName, entry.th32ProcessID);

                // Get HWND of the window
                HWND hWindow = FindWindowEx(NULL, NULL, NULL, "I Wanna Maker");
                if (hWindow != NULL)
                {
                    // Get the thread ID of the window
                    DWORD threadID;
                    GetWindowThreadProcessId(hWindow, &threadID);
                    if (threadID == entry.th32ProcessID)
                    {
                        Memory::hWindowHandle = hWindow;
                    }
                }
            }
        }
    }

    return true;
};

DWORD Memory::GetModuleBaseAddress(TCHAR* lpszModuleName, DWORD pID) {
    DWORD dwModuleBaseAddress = 0;
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pID); // make snapshot of all modules within process
    MODULEENTRY32 ModuleEntry32 = { 0 };
    ModuleEntry32.dwSize = sizeof(MODULEENTRY32);

    if (Module32First(hSnapshot, &ModuleEntry32)) //store first Module in ModuleEntry32
    {
        do {
            if (_tcscmp(ModuleEntry32.szModule, lpszModuleName) == 0) // if Found Module matches Module we look for -> done!
            {
                dwModuleBaseAddress = (DWORD)ModuleEntry32.modBaseAddr;
                break;
            }
        } while (Module32Next(hSnapshot, &ModuleEntry32)); // go through Module entries in Snapshot and store in ModuleEntry32


    }
    CloseHandle(hSnapshot);
    return dwModuleBaseAddress;
};

DWORD Memory::GetPointerAddress(DWORD address, std::vector<DWORD> offsets)
{
    DWORD pID = NULL; // Game process ID
    GetWindowThreadProcessId(hWindowHandle, &pID);
    HANDLE phandle = NULL;
    phandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pID);

    if (phandle == INVALID_HANDLE_VALUE || phandle == NULL);

    DWORD offset_null = NULL;
    ReadProcessMemory(phandle, (LPVOID*)(gameBaseAddress + address), &offset_null, sizeof(offset_null), 0);
    DWORD pointeraddress = offset_null; // the address we need
    for (int i = 0; i < offsets.size() - 1; i++) // we dont want to change the last offset value so we do -1
    {
        ReadProcessMemory(phandle, (LPVOID*)(pointeraddress + offsets.at(i)), &pointeraddress, sizeof(pointeraddress), 0);

    }
    return pointeraddress += offsets.at(offsets.size() - 1); // adding the last offset
}

HANDLE Memory::getProcess() {
    return Memory::hProcess;
}

DWORD Memory::getGameBaseAddress() {
    return Memory::gameBaseAddress;
}

HWND Memory::getWindowHandle() {
    return Memory::hWindowHandle;
}

Memory* mem = new Memory();